<?php

/**
 * @file
 * noty Messages
 * A noty based override of Drupal's core message system
 */

/**
 * Define Default Values
 */
// Passed to JS.
define('NOTY_LAYOUT', 'topRight');
define('NOTY_TEXT_ALIGN', 'left');
define('NOTY_SPEED', 500);
define('NOTY_TIMEOUT', 5000);
define('NOTY_CLOSABLE', TRUE);
define('NOTY_CLICK_CLOSE', TRUE);
define('NOTY_MODAL', FALSE);
define('NOTY_TYPE', 'success');
define('NOTY_THEME', 'noty_theme_default');

// Config.
define('NOTY_ADMIN_PATH_DISABLE', FALSE);
define('NOTY_IS_NOTY', FALSE);
define('NOTY_USE_GLOBAL', TRUE);

/**
 * Implements hook_permission().
 */
function noty_messages_permission() {
  return array(
    'view noty messages' => array(
      'title' => 'View noty messages',
    ),
    'administer noty messages' => array(
      'title' => 'Administer noty messages',
    ),
  );
}

/**
 * Implements hook_help().
 */
function noty_messages_help($path, $arg) {
  if ($path == 'admin/settings/noty') {
    return t('Set your options and decide whether you want the noty styled messages
      to appear on admin pages or not.');
  }
}

/**
 * Implements hook_menu().
 */
function noty_messages_menu() {
  $items = array();
  $items['admin/config/user-interface/noty-messages'] = array(
    'title' => 'Configure noty Messages',
    'description' => 'Settings to control noty messages',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('noty_messages_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer noty messages'),
    'file' => 'noty_messages.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function noty_messages_theme($existing, $type, $theme, $path) {
  return array(
    'original_status_messages' => array(
      'variables' => array('type' => NULL, 'messages' => NULL),
    ),
  );
}

/**
 * Implements hook_theme_registry_alter().
 */
function noty_messages_theme_registry_alter(&$theme_registry) {
  $theme_registry['status_messages']['function'] = 'noty_messages_status_messages';
}


/**
 * Checks for the existence of devel code
 *
 * @param string $message
 *   message string
 *
 * @return BOOL
 *   TRUE / FALSE based on whether devel msg or not
 */
function _noty_messages_devel_check($message) {
  if (strstr($message, '<pre>') || strstr($message, '<textarea') ||
    strstr($message, 'krumo')) {
    // Devel message found.
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Determines if a regular message should be returned or a noty message
 *
 * @param string $type
 *   Type of messages
 * @param array $messages
 *   Array of messages
 *
 * @return BOOL
 *   a BOOL deciding if noty messages should be rendered of regular ones
 */
function noty_messages_type($type, $messages) {
  // Assume TRUE.
  $is_noty = TRUE;
  // Check type visibility.
  $active_types = variable_get('noty_messages_is_noty', _noty_messages_get_default(array($type), NOTY_IS_NOTY));
  if (empty($active_types[$type])) {
    return FALSE;
  }
  // Should the messages be shown on admin paths?
  if (path_is_admin(current_path())) {
    $admin_path_settings = variable_get('noty_messages_admin_path_disable', _noty_messages_get_default(array($type), NOTY_ADMIN_PATH_DISABLE));
    if (!empty($admin_path_settings[$type])) {
      return FALSE;
    }
  }
  // If no other conditions have return FALSE by now, show type.
  return $is_noty;
}

/**
 * Checks to see whether the custom files exist.
 *
 * Checks current theme for custom CSS. Also returns the correct path
 * depending on where the function has been called from.
 *
 * @param bool $themelayer
 *   (optional) Boolean determines where function has been called from.
 *
 * @return string
 *   A string containing the path to the custom css or default one.
 */
function noty_messages_get_custom_css($themelayer = FALSE, $theme = NULL) {
  if (empty($theme)) {
    // We're looking for core noty css additions.
    $file = 'noty.css';
  }
  else {
    $file = $theme . '.css';
  }
  if ($themelayer == TRUE) {
    // Called from theme function so path_to_theme returns incorrect result.
    global $theme;
    $custom_css = drupal_get_path('theme', $theme) . '/notycss/' . $file;
  }
  else {
    // Called from non theme function (admin).
    $custom_css = path_to_theme() . '/notycss/' . $file;
  }
  if (!is_file($custom_css)) {
    return FALSE;
  }
  return $custom_css;
}

/**
 * Prepare page for noty_messages, only there are noty_messages to be rendered.
 */
function noty_messages_messages_setup($admin = FALSE) {
  // @todo probably preload all files in admin?
  $options = array(
    'type' => 'file',
    'scope' => 'header',
    'group' => JS_DEFAULT,
  );
  $module_path = drupal_get_path('module', 'noty_messages');
  $lib_path = libraries_get_path('noty');
  drupal_add_js($lib_path . '/js/promise.js', $options);
  drupal_add_js($lib_path . '/js/jquery.noty.js', $options);
  drupal_add_js($module_path . '/js/noty.js', $options);
  drupal_add_css($lib_path . '/css/jquery.noty.css');
  $custom_css = noty_messages_get_custom_css($themelayer = TRUE);
  if (!empty($custom_css)) {
    drupal_add_css($custom_css);
  }

  // If this is not being called from admin, normal behavior.
  if (empty($admin)) {
    $theme = variable_get('noty_messages_theme', _noty_messages_get_default('global', NOTY_THEME));
    // Only care about global for now. May change in the future.
    $theme = $theme['global'];
    // Add custom css.
    $theme_css = noty_messages_get_custom_css(TRUE, $theme);
    if (!empty($theme_css)) {
      drupal_add_css($theme_css);
    }
    else {
      // Fall back to default css.
      drupal_add_css($lib_path . '/css/' . $theme . '.css');
    }
  }
  // If this is coming from admin, load all css files.
  // @todo should have some kind of hooking here or a get all themes function.
  else {
    $themes = array(
      'noty_theme_default',
      'noty_theme_custom',
      'noty_theme_mitgux',
    );
    foreach ($themes as $theme) {
      $theme_css = noty_messages_get_custom_css(TRUE, $theme);
      if (empty($theme_css) && $theme != 'noty_theme_custom') {
        drupal_add_css($lib_path . '/css/' . $theme . '.css');
      }
      else {
        drupal_add_css($theme_css);
      }
    }
  }
  $js_settings = array();
  $message_types = _noty_messages_get_types();
  $config = _noty_messages_get_config('js', TRUE, $message_types);
  foreach ($config as $key => $value) {
    // Do some string replacement so js is nice.
    $js_settings['noty' . $key] = $value;
  }
  drupal_add_js(array('notyMessages' => $js_settings), 'setting');
}
/**
 * Builds a set of noty messages for a type and returns it
 *
 * @param string $type
 *   type of message
 * @param array $messages
 *   array of messages to build
 *
 * @return array
 *   an array of messages
 */
function noty_messages_build_messages($type, $messages) {
  $noties_of_type = array();
  foreach ($messages as $key => $message) {
    if (_noty_messages_devel_check($message)) {
      $noties_of_type['devels'][$key] = $message;
    }
    else {
      $noties_of_type['noties'][$key] = $message;
    }
  }
  return $noties_of_type;
}

/**
 * Decides which messages should be noties and builds for theme
 */
function noty_messages_status_messages($variables) {
  $display = $variables['display'];
  $output = '';
  $noties = array();
  $originals = array();
  $devels = array();
  $noty_out = '';
  $originals_out = '';
  $devels_out = '';
  $displayed_messages = drupal_get_messages($display);

  foreach ($displayed_messages as $type => $messages) {
    if (noty_messages_type($type, $messages)) {
      $noties[$type] = noty_messages_build_messages($type, $messages);
      if (!empty($noties[$type]['devels'])) {
        $devels[$type] = $noties[$type]['devels'];
      }
      // Wipe out the devels and move the array one level up.
      $noties[$type] = $noties[$type]['noties'];
    }
    else {
      $originals[$type] = $messages;
    }
  }
  // Render noties first.
  $noties = array_filter($noties);
  $originals = array_filter($originals);
  $devels = array_filter($devels);
  if (!empty($noties)) {
    $jq_inline = noty_messages_messages_setup($noties);
    drupal_add_js(array('notyMessagesNoties' => $noties), array('type' => 'setting', 'cache' => FALSE));
  }
  if (!empty($originals)) {
    foreach ($originals as $type => $messages) {
      $originals_out .= theme('original_status_messages', array('type' => $type, 'messages' => $messages));
    }
  }
  if (!empty($devels)) {
    foreach ($devels as $type => $messages) {
      $devels_out .= implode(' ', $messages);
    }
  }
  $output = $originals_out . $devels_out;
  return $output;
}

/**
 * Return a themed set of status and/or error messages grouped by type
 *
 * This is the original output which we use if noty messages is turned off.
 *
 * @param array $vars
 *   Array of theme variables
 *
 * @return string
 *   A string containing the formatted messages.
 */
function theme_original_status_messages($vars) {
  $type = $vars['type'];
  $messages = $vars['messages'];
  $output = '';
  $output .= "<div class=\"messages $type\">\n";
  if (count($messages) > 1) {
    $output .= " <ul>\n";
    foreach ($messages as $message) {
      $output .= '  <li>' . $message . "</li>\n";
    }
    $output .= " </ul>\n";
  }
  else {
    $output .= $messages[0];
  }
  $output .= "</div>\n";
  return $output;
}

/**
 * Helper function for building arrays to go into the variables
 *
 * @param array $message_types
 *   Array of message types to set the value for
 * @param mixed $value
 *   The value to set
 *
 * @return array
 *   a constructed array of values
 */
function _noty_messages_get_default($message_types, $value) {
  $return = array();
  if (is_array($value)) {
    return $value;
  }
  if (!is_array($message_types)) {
    $message_types = array($message_types);
  }
  foreach ($message_types as $message_type) {
    $return[$message_type] = $value;
  }
  return $return;
}

/**
 * Helper function to retrieve configuration keys
 *
 * @param string $set
 *   One of 'all, js, single, global'.
 *   all = All Configuration
 *   js = javascript settings
 *   single = only for message types, exclude globals
 *   global = only for global config, exclude message types
 * @param bool $with_values
 *   Whether to get the values or just return an array of keys
 * @param array $message_types
 *   An array of message types to get configuration build for
 *
 * @return array
 *   An array of config settings
 */
function _noty_messages_get_config($set = 'all', $with_values = FALSE, $message_types = NULL) {
  $config_keys = array(
    'layout' => 'Layout',
    'text_align' => 'TextAlign',
    'speed' => 'Speed',
    'timeout' => 'Timeout',
    'closable' => 'Closable',
    'click_close' => 'ClickClose',
    'modal' => 'Modal',
    'type' => 'Type',
    'theme' => 'Theme',
  );
  if ($set == 'single' || $set == 'all') {
    $config_keys['use_global'] = 'use_global';
  }
  if ($set == 'global' || $set == 'all') {
    $config_keys['is_noty'] = 'is_noty';
  }
  if ($set != 'js') {
    $config_keys['admin_path_disable'] = 'admin_path_disable';
  }
  if ($with_values == FALSE) {
    if ($set != 'js') {
      $config_keys = array_flip($config_keys);
    }
    return array_values($config_keys);
  }
  if ($set != 'js') {
    $config_keys = array_values(array_flip($config_keys));
    foreach ($config_keys as $key => $value) {
      $config_keys[$value] = variable_get('noty_messages_' . $value, _noty_messages_get_default($message_types, constant(strtoupper('noty_' . $value))));
      unset($config_keys[$key]);
    }
  }
  else {
    foreach ($config_keys as $key => $value) {
      $config_keys[$value] = variable_get('noty_messages_' . $key, _noty_messages_get_default($message_types, constant(strtoupper('noty_' . $key))));
      unset($config_keys[$key]);
    }
    $config_keys['MessageTypes'] = $message_types;
  }
  return $config_keys;
}
/**
 * Helper function for getting message types
 *
 *  @param bool $include_globals
 *   Whether globals should be included
 */
function _noty_messages_get_types($include_globals = FALSE) {
  $types = drupal_map_assoc(array('status', 'warning', 'error'));
  if ($include_globals == TRUE) {
    $types = array_merge($types, drupal_map_assoc(array('global')));
  }
  return $types;
}
